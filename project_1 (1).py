# -*- coding: utf-8 -*-
"""Project 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B2g-BCN_VuLhYUxokGa8QNJhWGGh6fam
"""

# a and b are assumed to be positive integers
def algorithm(a, b):
  count = 0
  for i in range(1,a+1):
    for j in range(1,b+1):
      if i == j and a%i ==0 and b%j == 0:
        count += 1
  return count == 0

"""1.
What relationship between a and b will the algorithm discover?

*The algorithm is essentially checking for common divisors of a and b.

*It increments count whenever i == j and both a % i == 0 and b % j == 0.

*That means it is checking whether i is a divisor of both a and b.

*At the end, it returns True if no common divisor exists.

*But since 1 is always a divisor, the only time it returns True is when a and b are coprime (gcd(a, b) = 1).

*Answer: The algorithm determines whether a and b are relatively prime (gcd(a, b) = 1)

example below:
"""

algorithm(25, 11)

"""2.
What is a tight upper bound (Big-O) on the running time of the algorithm?

*The outer loop runs a times.

*The inner loop runs b times.

*Inside, the check is constant time O(1).

*So total time = O(a × b).
Answer: Tight upper bound = O(a × b)

3.
Modify the algorithm to improve its Big-O complexity.

*Instead of brute-force checking all pairs (i, j), we can directly compute the gcd using the Euclidean algorithm.

*improved version below:
"""

from math import gcd

def improved_algorithm(a, b):
    return gcd(a, b) == 1

improved_algorithm(25, 11)

"""Part 2: plotting points

1. Plot f(n) = n vs. f(n) = log(n)
"""

import numpy as np
import matplotlib.pyplot as plt
import math
n = np.arange(1, 100, 1)
plt.plot(n, n, label="f(n) = n")
plt.plot(n, np.log(n), label="f(n) = log(n)")
plt.xlabel("n")
plt.ylabel("f(n)")
plt.title("f(n) = n vs f(n) = log(n)")
plt.legend()
plt.grid(True)
plt.show()

"""2. Plot f(n) = n vs. f(n) = n"""

n = np.arange(1, 100, 1)
plt.plot(n, n, label="f(n) = n")
plt.plot(n, n, label="f(n) = n (comparison)")
plt.xlabel("n")
plt.ylabel("f(n)")
plt.title("f(n) = n vs f(n) = n")
plt.legend()
plt.grid(True)
plt.show()

"""3. Plot f(n) = n vs. f(n) = n^2"""

n = np.arange(1, 100, 1)
plt.plot(n, n, label="f(n) = n")
plt.plot(n, n**2, label="f(n) = n^2")
plt.xlabel("n")
plt.ylabel("f(n)")
plt.title("f(n) = n vs f(n) = n^2")
plt.legend()
plt.grid(True)
plt.show()

"""4. Plot f(n) = n vs. f(n) = 2^n"""

n = np.arange(1, 20, 1)   # smaller range, because 2^n grows FAST
plt.plot(n, n, label="f(n) = n")
plt.plot(n, 2**n, label="f(n) = 2^n")
plt.xlabel("n")
plt.ylabel("f(n)")
plt.title("f(n) = n vs f(n) = 2^n")
plt.legend()
plt.grid(True)
plt.show()

"""5. Plot f(n) = n vs. f(n) = n!"""

n = np.arange(1, 10, 1)   # very small range, factorial grows super fast
factorial_values = [math.factorial(i) for i in n]

plt.plot(n, n, label="f(n) = n")
plt.plot(n, factorial_values, label="f(n) = n!")
plt.xlabel("n")
plt.ylabel("f(n)")
plt.title("f(n) = n vs f(n) = n!")
plt.legend()
plt.grid(True)
plt.show()